# Transaction

데이터베이스에서 트랜잭션이란 하나의 거래를 안전하게 처리하도록 보장해주는 것이다.  

5000원을 계좌이체 했을때,
1. A의 잔고를 5000원 감소
2. B의 잔고를 5000원 증가

1만 성공했을 시에 2가 안되면 심각한 문제가 생긴다.  
트랙잭션이란 이 두가지 모두가 성공해야지 끝나고 아니면 롤백시키는 것이다.  

## ACID
원자성: 트랜잭션 내의 실행한 작업은 마치 하나의 작업인 것 처럼 한다.  
일관성: 일관성있는 데이터베이스 상태를 유지해야 한다.  
격리성: 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않아야 한다. 격리성은 성능 이슈로 인해서 트랜잭션 `격리 수준`을 선택할 수 있다.  
지속성: 트랜잭션이 성공적으로 끝나면 그 결과가 항상 기록되어야 한다.  

### 격리수준
READ UNCOMMITED(커밋되지 않은 읽기)  
READ COMMITED(커밋된 읽기) - 기본으로 많이 사용  
REPEATABLE READ(반복 가능한 읽기)  
SERIALIZABLE(직렬화 가능)  

## 데이터 베이스 연결 구조와 DB 세션
클라이언트 -> DB커넥션(클라이언트, DB 모두 존재) -> 세션  
세션: 트랜잭션을 시작하고, 커밋 또는 콜맥을 통해 트랜잭션을 종료한다.  
커넥션 풀이 10개의 커넥션을 생성하면 세션또한 10개가 생성된다.  

## 트랜잭션 사용법
DB에 결과를 반영하기 위해서는 `commit`을 호출해야한다.(반영하고 싶지않다면 `rollback`)  
commit을 호출하기 전까진 임시로 데이터를 저장하는 수준이다.
> 변경한 사용자에게만 반영결과가 보이고 다른 세션의 사용자에게는 변경점이 보이지 않는다.  
> 
> **커밋되지 않은 데이터 사용 문제점**  
> 커밋하지 않은 데이터가 다른 곳에서 조회가 되면 롤백을 수행하게 된다면  
> 그 중간지점에 데이터를 사용한 사람이 생겨 정합성의 문제가 생긴다.

## 자동 커밋, 수동 커밋
자동 커밋: 쿼리 실행 직후 자동으로 커밋 호출(default)
수동 커밋: 수동으로 커밋 호출

```shell
set autocommit true;   # 자동
set autocommit false ; # 수동

commit; # 수동커밋은 다음과 같은 명령어를 호출 해주어야한다.
```

## DB 락
세션1이 트랜잭션을 시작하고 수정하는 동안 커밋을 수행하지 않을때, 세션2에서 데이터를 수정하게 된다면?  
원자성을 보장해주지 못한다.  
=> 이런 것을 해결해주기 위해 Lock이라는 개념을 제공한다.

### 변경
먼저 들어온 세션에 우선권을 준다.  
1. 세션1은 트랜잭션을 시작한다.
2. 세션1은 업데이트시에 해당 row의 락을 먼저 획득해야 한다.(다른 곳에서 락을 걸지 않으면 획득)
3. 세션1은 획득 했으므로 update sql 수행
4. 세션2도 트랜잭션 시작한다.
5. 세션2도 동일한 row를 변경시도할 때, 락으로 인해 대기한다.(일정 시간이 넘어가면 락 타임아웃)
6. 세션1이 커밋후 락을 반납
7. 세션2가 락을 받은 후에 update sql을 수행한다.
8. 세션2도 커밋후 락을 반납 한다.

### 조회
다른 세션에서 락을 획득하고 있어도 조회는 커밋되지 않은 경우의 데이터로 조회가 가능하다.  
하지만 락을 걸 수 있는 경우가 있다.   
=> 트랜잭션 종료시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.  
> 계산이 돈과 관련된 계산일때, 변경중에 다른 곳에서 조회시 문제가 생길 수 있는 상황이 있다.  

## 문제점들

어플리케이션의 구조
- 프레젠테이션 계층: UI 처리, 웹 요청과 응답, 사용자 요청을 검증
- 서비스 계층: 비즈니스 로직
- 데이터 접근 계층: 실제 데이터베이스에 접근하는 코드

### 순수한 서비스 계층
가장 중요한 곳은 서비스 계층이다.  
프레젠테이션 계층이나 데이터 접근 계층은 기술의 발전으로 변경점이 생길 일이 더 많다.  
이에 따라서 서비스 계층은 종속적이지 않게 개발하는 것이 좋다.  

## 트랜잭션 매니져

트랜잭션 추상화, 리소스 동기화의 역할을 맡는다.

### 트랜잭션 추상화
트랜잭션을 비즈니스 로직에 사용하는 경우에 비즈니스 로직이 트랜잭션 코드에 의존적이다.  
향후에 데이터 접근 기술을 변경하게 되었을 시에는 모든 비즈니스 로직의 수정이 불가피 하다.  

따라서, 트랜잭션의 추상화(begin, rollback, commit 등)를 통해서 구현체를 받아 해결할 수 있다.

### 리소스 동기화
트랜잭션을 하려면 같은 커넥션을 유지하는 것이 핵심이다.  
이를 이전에는 파라미터로 Connection 객체를 넘겨주면서 해결했지만,  
그렇게 하면 단점으로 코드가 지저분해지고, 메서드를 중복으로 만들어줘야하는 단점이 생긴다.  

spring은 `트랜잭션 동기화 매니저`를 제공하게 된다.  
> 커넥션을 보관해주는 역할을 한다고 알고 있으면 된다.  


## 트랜잭션 프록시

프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 분리할 수 있다.  
트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다.  

AOP의 기능을 통해서 해결할수 있다. 하지만 spring에서는 기본적으로 transaction은 제공한다. : `@Transactional`

### 선언전 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리

**선언전 트랜잭션 관리**
@Transactional처럼 선언을 통해서 트랜잭션을 관리.
아래 프로젝트에서 AOP를 사용한 것.

**프로그래밍 방식 트랜잭션 관리**
실제로 트랜잭션을 관련 코드를 직접 작성하여 관리.
AOP를 제외한 모든 방법이 직접 프로그래밍을 하여 트랜잭션을 걸어주고 있다.